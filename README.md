# Optimising-Group-Degree-Generation-for-Bipartite-Network
Here we explore the optimisation of group degree generation. The following cell focuses on comparing the execution times and CPU usage between non-optimized and optimised approaches for generating group degree sequences.

## Description:
This Jupyter Notebook explores the optimization of group degree generation in network analysis using Python. The notebook focuses on comparing the execution times and CPU usage between non-optimized and optimized approaches for generating group degree sequences. Group degree sequences play a crucial role in various network analysis applications, including social networks, communication networks, and more.

The notebook presents two main code sections: `run_code_1(n)` and `run_code_2(n)`. The former represents the non-optimized approach, while the latter demonstrates the optimized approach. Each code section generates group degree sequences with specific characteristics, leveraging concepts such as truncated normal distribution and Poisson distribution.

Throughout the notebook, the execution times and CPU usage for both approaches are measured and compared. The exploration is conducted for different values of 'n' (the size of the network), including 100, 500, 1000, 2000, 5000, 10000, 20000, 50000, 80000, and 100000. For each 'n' value, the notebook calculates and records the execution times and CPU usage, providing insights into the efficiency of the optimized approach.

